
FreeRTOS_lab.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001c  00800100  00000ce8  00000d7c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000ce8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000640  0080011c  0080011c  00000d98  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000d98  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000dc8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000228  00000000  00000000  00000e08  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002988  00000000  00000000  00001030  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000ef2  00000000  00000000  000039b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000018a8  00000000  00000000  000048aa  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000005e4  00000000  00000000  00006154  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000f76  00000000  00000000  00006738  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001f5c  00000000  00000000  000076ae  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000250  00000000  00000000  0000960a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	45 c0       	rjmp	.+138    	; 0x8c <__ctors_end>
   2:	00 00       	nop
   4:	60 c0       	rjmp	.+192    	; 0xc6 <__bad_interrupt>
   6:	00 00       	nop
   8:	5e c0       	rjmp	.+188    	; 0xc6 <__bad_interrupt>
   a:	00 00       	nop
   c:	5c c0       	rjmp	.+184    	; 0xc6 <__bad_interrupt>
   e:	00 00       	nop
  10:	5a c0       	rjmp	.+180    	; 0xc6 <__bad_interrupt>
  12:	00 00       	nop
  14:	58 c0       	rjmp	.+176    	; 0xc6 <__bad_interrupt>
  16:	00 00       	nop
  18:	56 c0       	rjmp	.+172    	; 0xc6 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	54 c0       	rjmp	.+168    	; 0xc6 <__bad_interrupt>
  1e:	00 00       	nop
  20:	52 c0       	rjmp	.+164    	; 0xc6 <__bad_interrupt>
  22:	00 00       	nop
  24:	50 c0       	rjmp	.+160    	; 0xc6 <__bad_interrupt>
  26:	00 00       	nop
  28:	4e c0       	rjmp	.+156    	; 0xc6 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	4c c0       	rjmp	.+152    	; 0xc6 <__bad_interrupt>
  2e:	00 00       	nop
  30:	4a c0       	rjmp	.+148    	; 0xc6 <__bad_interrupt>
  32:	00 00       	nop
  34:	f0 c2       	rjmp	.+1504   	; 0x616 <__vector_13>
  36:	00 00       	nop
  38:	46 c0       	rjmp	.+140    	; 0xc6 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	44 c0       	rjmp	.+136    	; 0xc6 <__bad_interrupt>
  3e:	00 00       	nop
  40:	42 c0       	rjmp	.+132    	; 0xc6 <__bad_interrupt>
  42:	00 00       	nop
  44:	40 c0       	rjmp	.+128    	; 0xc6 <__bad_interrupt>
  46:	00 00       	nop
  48:	3e c0       	rjmp	.+124    	; 0xc6 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	3c c0       	rjmp	.+120    	; 0xc6 <__bad_interrupt>
  4e:	00 00       	nop
  50:	3a c0       	rjmp	.+116    	; 0xc6 <__bad_interrupt>
  52:	00 00       	nop
  54:	38 c0       	rjmp	.+112    	; 0xc6 <__bad_interrupt>
  56:	00 00       	nop
  58:	36 c0       	rjmp	.+108    	; 0xc6 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	34 c0       	rjmp	.+104    	; 0xc6 <__bad_interrupt>
  5e:	00 00       	nop
  60:	32 c0       	rjmp	.+100    	; 0xc6 <__bad_interrupt>
  62:	00 00       	nop
  64:	30 c0       	rjmp	.+96     	; 0xc6 <__bad_interrupt>
  66:	00 00       	nop
  68:	2e c0       	rjmp	.+92     	; 0xc6 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	2c c0       	rjmp	.+88     	; 0xc6 <__bad_interrupt>
  6e:	00 00       	nop
  70:	2a c0       	rjmp	.+84     	; 0xc6 <__bad_interrupt>
  72:	00 00       	nop
  74:	28 c0       	rjmp	.+80     	; 0xc6 <__bad_interrupt>
  76:	00 00       	nop
  78:	26 c0       	rjmp	.+76     	; 0xc6 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	24 c0       	rjmp	.+72     	; 0xc6 <__bad_interrupt>
  7e:	00 00       	nop
  80:	22 c0       	rjmp	.+68     	; 0xc6 <__bad_interrupt>
  82:	00 00       	nop
  84:	20 c0       	rjmp	.+64     	; 0xc6 <__bad_interrupt>
  86:	00 00       	nop
  88:	1e c0       	rjmp	.+60     	; 0xc6 <__bad_interrupt>
	...

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e4       	ldi	r29, 0x40	; 64
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	e8 ee       	ldi	r30, 0xE8	; 232
  a0:	fc e0       	ldi	r31, 0x0C	; 12
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	ac 31       	cpi	r26, 0x1C	; 28
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
  b2:	27 e0       	ldi	r18, 0x07	; 7
  b4:	ac e1       	ldi	r26, 0x1C	; 28
  b6:	b1 e0       	ldi	r27, 0x01	; 1
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	ac 35       	cpi	r26, 0x5C	; 92
  be:	b2 07       	cpc	r27, r18
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	86 d0       	rcall	.+268    	; 0x1d0 <main>
  c4:	0f c6       	rjmp	.+3102   	; 0xce4 <_exit>

000000c6 <__bad_interrupt>:
  c6:	9c cf       	rjmp	.-200    	; 0x0 <__vectors>

000000c8 <ButtonTask>:
#include "task.h" 
#include "croutine.h" 
enum LEDState {INIT,L0,L1,} led_state0, led_val, button ;

void LEDS_Init(){
	led_state0 = INIT;
  c8:	cf ef       	ldi	r28, 0xFF	; 255
  ca:	00 9b       	sbis	0x00, 0	; 0
  cc:	c0 93 5a 07 	sts	0x075A, r28	; 0x80075a <button>
  d0:	8a e0       	ldi	r24, 0x0A	; 10
  d2:	90 e0       	ldi	r25, 0x00	; 0
  d4:	91 d5       	rcall	.+2850   	; 0xbf8 <vTaskDelay>
  d6:	f9 cf       	rjmp	.-14     	; 0xca <ButtonTask+0x2>

000000d8 <LEDS_Tick0>:
}

void LEDS_Tick0(){
	//Actions
	switch(led_state0){
  d8:	80 91 5b 07 	lds	r24, 0x075B	; 0x80075b <led_state0>
  dc:	81 30       	cpi	r24, 0x01	; 1
  de:	81 f0       	breq	.+32     	; 0x100 <LEDS_Tick0+0x28>
  e0:	18 f0       	brcs	.+6      	; 0xe8 <LEDS_Tick0+0x10>
  e2:	82 30       	cpi	r24, 0x02	; 2
  e4:	99 f0       	breq	.+38     	; 0x10c <LEDS_Tick0+0x34>
  e6:	18 c0       	rjmp	.+48     	; 0x118 <LEDS_Tick0+0x40>
		case INIT:
            PORTD = 0;
  e8:	1b b8       	out	0x0b, r1	; 11
            led_val = 1;
  ea:	81 e0       	ldi	r24, 0x01	; 1
  ec:	80 93 59 07 	sts	0x0759, r24	; 0x800759 <led_val>
		default:
            PORTD = 0;
            break;
	}
	//Transitions
	switch(led_state0){
  f0:	80 91 5b 07 	lds	r24, 0x075B	; 0x80075b <led_state0>
  f4:	81 30       	cpi	r24, 0x01	; 1
  f6:	09 f1       	breq	.+66     	; 0x13a <LEDS_Tick0+0x62>
  f8:	c0 f0       	brcs	.+48     	; 0x12a <LEDS_Tick0+0x52>
  fa:	82 30       	cpi	r24, 0x02	; 2
  fc:	b1 f5       	brne	.+108    	; 0x16a <LEDS_Tick0+0x92>
  fe:	27 c0       	rjmp	.+78     	; 0x14e <LEDS_Tick0+0x76>
		case INIT:
            PORTD = 0;
            led_val = 1;
            break;
		case L0:
            led_val = (led_val << 1);
 100:	80 91 59 07 	lds	r24, 0x0759	; 0x800759 <led_val>
 104:	88 0f       	add	r24, r24
 106:	80 93 59 07 	sts	0x0759, r24	; 0x800759 <led_val>
 10a:	13 c0       	rjmp	.+38     	; 0x132 <LEDS_Tick0+0x5a>
            break;
		case L1:
            led_val = (led_val >> 1);
 10c:	80 91 59 07 	lds	r24, 0x0759	; 0x800759 <led_val>
 110:	86 95       	lsr	r24
 112:	80 93 59 07 	sts	0x0759, r24	; 0x800759 <led_val>
 116:	1b c0       	rjmp	.+54     	; 0x14e <LEDS_Tick0+0x76>
            break;
		default:
            PORTD = 0;
 118:	1b b8       	out	0x0b, r1	; 11
            break;
	}
	//Transitions
	switch(led_state0){
 11a:	80 91 5b 07 	lds	r24, 0x075B	; 0x80075b <led_state0>
 11e:	81 30       	cpi	r24, 0x01	; 1
 120:	41 f0       	breq	.+16     	; 0x132 <LEDS_Tick0+0x5a>
 122:	18 f0       	brcs	.+6      	; 0x12a <LEDS_Tick0+0x52>
 124:	82 30       	cpi	r24, 0x02	; 2
 126:	09 f5       	brne	.+66     	; 0x16a <LEDS_Tick0+0x92>
 128:	12 c0       	rjmp	.+36     	; 0x14e <LEDS_Tick0+0x76>
		case INIT:
			led_state0 = L0;
 12a:	81 e0       	ldi	r24, 0x01	; 1
 12c:	80 93 5b 07 	sts	0x075B, r24	; 0x80075b <led_state0>
            break;
 130:	1e c0       	rjmp	.+60     	; 0x16e <LEDS_Tick0+0x96>
		case L0:
            if(led_val == 0x80 || button){
 132:	80 91 59 07 	lds	r24, 0x0759	; 0x800759 <led_val>
 136:	80 38       	cpi	r24, 0x80	; 128
 138:	21 f0       	breq	.+8      	; 0x142 <LEDS_Tick0+0x6a>
 13a:	80 91 5a 07 	lds	r24, 0x075A	; 0x80075a <button>
 13e:	88 23       	and	r24, r24
 140:	b1 f0       	breq	.+44     	; 0x16e <LEDS_Tick0+0x96>
                led_state0 = L1;
 142:	82 e0       	ldi	r24, 0x02	; 2
 144:	80 93 5b 07 	sts	0x075B, r24	; 0x80075b <led_state0>
                button = 0;
 148:	10 92 5a 07 	sts	0x075A, r1	; 0x80075a <button>
 14c:	10 c0       	rjmp	.+32     	; 0x16e <LEDS_Tick0+0x96>
            }                           
            break;
		case L1:
			 if(led_val == 0x01  || button){
 14e:	80 91 59 07 	lds	r24, 0x0759	; 0x800759 <led_val>
 152:	81 30       	cpi	r24, 0x01	; 1
 154:	21 f0       	breq	.+8      	; 0x15e <LEDS_Tick0+0x86>
 156:	80 91 5a 07 	lds	r24, 0x075A	; 0x80075a <button>
 15a:	88 23       	and	r24, r24
 15c:	41 f0       	breq	.+16     	; 0x16e <LEDS_Tick0+0x96>
                led_state0 = L0;
 15e:	81 e0       	ldi	r24, 0x01	; 1
 160:	80 93 5b 07 	sts	0x075B, r24	; 0x80075b <led_state0>
                button = 0;    
 164:	10 92 5a 07 	sts	0x075A, r1	; 0x80075a <button>
 168:	02 c0       	rjmp	.+4      	; 0x16e <LEDS_Tick0+0x96>
             }
            break;
		default:
			led_state0 = INIT;
 16a:	10 92 5b 07 	sts	0x075B, r1	; 0x80075b <led_state0>
            break;
	}
    PORTD = led_val;
 16e:	80 91 59 07 	lds	r24, 0x0759	; 0x800759 <led_val>
 172:	8b b9       	out	0x0b, r24	; 11
 174:	08 95       	ret

00000176 <LedSecTask0>:
#include "task.h" 
#include "croutine.h" 
enum LEDState {INIT,L0,L1,} led_state0, led_val, button ;

void LEDS_Init(){
	led_state0 = INIT;
 176:	10 92 5b 07 	sts	0x075B, r1	; 0x80075b <led_state0>


void LedSecTask0() {
    LEDS_Init();
    for(;;) { 	
        LEDS_Tick0();
 17a:	ae df       	rcall	.-164    	; 0xd8 <LEDS_Tick0>
        vTaskDelay(500); 
 17c:	84 ef       	ldi	r24, 0xF4	; 244
 17e:	91 e0       	ldi	r25, 0x01	; 1
 180:	3b d5       	rcall	.+2678   	; 0xbf8 <vTaskDelay>
 182:	fb cf       	rjmp	.-10     	; 0x17a <LedSecTask0+0x4>

00000184 <StartSecPulse0>:
    }
}



void StartSecPulse0(unsigned portBASE_TYPE Priority) {
 184:	ef 92       	push	r14
 186:	ff 92       	push	r15
 188:	0f 93       	push	r16
    xTaskCreate(LedSecTask0, 
 18a:	e1 2c       	mov	r14, r1
 18c:	f1 2c       	mov	r15, r1
 18e:	08 2f       	mov	r16, r24
 190:	20 e0       	ldi	r18, 0x00	; 0
 192:	30 e0       	ldi	r19, 0x00	; 0
 194:	45 e5       	ldi	r20, 0x55	; 85
 196:	50 e0       	ldi	r21, 0x00	; 0
 198:	60 e0       	ldi	r22, 0x00	; 0
 19a:	71 e0       	ldi	r23, 0x01	; 1
 19c:	8b eb       	ldi	r24, 0xBB	; 187
 19e:	90 e0       	ldi	r25, 0x00	; 0
 1a0:	d0 d2       	rcall	.+1440   	; 0x742 <xTaskCreate>
            (signed portCHAR *)"LedSecTask0", 
            configMINIMAL_STACK_SIZE, 
            NULL, 
            Priority, 
            NULL );
}	
 1a2:	0f 91       	pop	r16
 1a4:	ff 90       	pop	r15
 1a6:	ef 90       	pop	r14
 1a8:	08 95       	ret

000001aa <StartSecPulse1>:

void StartSecPulse1(unsigned portBASE_TYPE Priority) {
 1aa:	ef 92       	push	r14
 1ac:	ff 92       	push	r15
 1ae:	0f 93       	push	r16
    xTaskCreate(ButtonTask,
 1b0:	e1 2c       	mov	r14, r1
 1b2:	f1 2c       	mov	r15, r1
 1b4:	08 2f       	mov	r16, r24
 1b6:	20 e0       	ldi	r18, 0x00	; 0
 1b8:	30 e0       	ldi	r19, 0x00	; 0
 1ba:	45 e5       	ldi	r20, 0x55	; 85
 1bc:	50 e0       	ldi	r21, 0x00	; 0
 1be:	6c e0       	ldi	r22, 0x0C	; 12
 1c0:	71 e0       	ldi	r23, 0x01	; 1
 1c2:	84 e6       	ldi	r24, 0x64	; 100
 1c4:	90 e0       	ldi	r25, 0x00	; 0
 1c6:	bd d2       	rcall	.+1402   	; 0x742 <xTaskCreate>
    (signed portCHAR *)"ButtonTask",
    configMINIMAL_STACK_SIZE,
    NULL,
    Priority,
    NULL );
}
 1c8:	0f 91       	pop	r16
 1ca:	ff 90       	pop	r15
 1cc:	ef 90       	pop	r14
 1ce:	08 95       	ret

000001d0 <main>:
 
int main(void) { 
    DDRA = 0x00; PORTA=0xFF;
 1d0:	11 b8       	out	0x01, r1	; 1
 1d2:	8f ef       	ldi	r24, 0xFF	; 255
 1d4:	82 b9       	out	0x02, r24	; 2
    DDRD = 0xFF;
 1d6:	8a b9       	out	0x0a, r24	; 10
    //Start Tasks  
    StartSecPulse0(1);
 1d8:	81 e0       	ldi	r24, 0x01	; 1
 1da:	d4 df       	rcall	.-88     	; 0x184 <StartSecPulse0>
    StartSecPulse1(50);
 1dc:	82 e3       	ldi	r24, 0x32	; 50
    //RunSchedular 
    vTaskStartScheduler(); 
 1de:	e5 df       	rcall	.-54     	; 0x1aa <StartSecPulse1>
 1e0:	ad d3       	rcall	.+1882   	; 0x93c <vTaskStartScheduler>
    return 0; 
}
 1e2:	80 e0       	ldi	r24, 0x00	; 0
 1e4:	90 e0       	ldi	r25, 0x00	; 0
 1e6:	08 95       	ret

000001e8 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 1e8:	cf 93       	push	r28
 1ea:	df 93       	push	r29
 1ec:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
 1ee:	ce d3       	rcall	.+1948   	; 0x98c <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
 1f0:	80 91 1c 01 	lds	r24, 0x011C	; 0x80011c <__data_end>
 1f4:	90 91 1d 01 	lds	r25, 0x011D	; 0x80011d <__data_end+0x1>
 1f8:	89 2b       	or	r24, r25
 1fa:	31 f4       	brne	.+12     	; 0x208 <pvPortMalloc+0x20>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 1fc:	81 e2       	ldi	r24, 0x21	; 33
 1fe:	91 e0       	ldi	r25, 0x01	; 1
 200:	90 93 1d 01 	sts	0x011D, r25	; 0x80011d <__data_end+0x1>
 204:	80 93 1c 01 	sts	0x011C, r24	; 0x80011c <__data_end>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 208:	20 91 1e 01 	lds	r18, 0x011E	; 0x80011e <xNextFreeByte>
 20c:	30 91 1f 01 	lds	r19, 0x011F	; 0x80011f <xNextFreeByte+0x1>
 210:	c9 01       	movw	r24, r18
 212:	8c 0f       	add	r24, r28
 214:	9d 1f       	adc	r25, r29
 216:	8b 3d       	cpi	r24, 0xDB	; 219
 218:	45 e0       	ldi	r20, 0x05	; 5
 21a:	94 07       	cpc	r25, r20
 21c:	70 f4       	brcc	.+28     	; 0x23a <pvPortMalloc+0x52>
 21e:	28 17       	cp	r18, r24
 220:	39 07       	cpc	r19, r25
 222:	70 f4       	brcc	.+28     	; 0x240 <pvPortMalloc+0x58>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 224:	c0 91 1c 01 	lds	r28, 0x011C	; 0x80011c <__data_end>
 228:	d0 91 1d 01 	lds	r29, 0x011D	; 0x80011d <__data_end+0x1>
 22c:	c2 0f       	add	r28, r18
 22e:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
 230:	90 93 1f 01 	sts	0x011F, r25	; 0x80011f <xNextFreeByte+0x1>
 234:	80 93 1e 01 	sts	0x011E, r24	; 0x80011e <xNextFreeByte>
 238:	05 c0       	rjmp	.+10     	; 0x244 <pvPortMalloc+0x5c>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
 23a:	c0 e0       	ldi	r28, 0x00	; 0
 23c:	d0 e0       	ldi	r29, 0x00	; 0
 23e:	02 c0       	rjmp	.+4      	; 0x244 <pvPortMalloc+0x5c>
 240:	c0 e0       	ldi	r28, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 242:	d0 e0       	ldi	r29, 0x00	; 0
 244:	60 d4       	rcall	.+2240   	; 0xb06 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
 246:	ce 01       	movw	r24, r28
 248:	df 91       	pop	r29
 24a:	cf 91       	pop	r28
 24c:	08 95       	ret

0000024e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 24e:	08 95       	ret

00000250 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 250:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 252:	03 96       	adiw	r24, 0x03	; 3
 254:	92 83       	std	Z+2, r25	; 0x02
 256:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 258:	2f ef       	ldi	r18, 0xFF	; 255
 25a:	3f ef       	ldi	r19, 0xFF	; 255
 25c:	34 83       	std	Z+4, r19	; 0x04
 25e:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 260:	96 83       	std	Z+6, r25	; 0x06
 262:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 264:	90 87       	std	Z+8, r25	; 0x08
 266:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 268:	10 82       	st	Z, r1
 26a:	08 95       	ret

0000026c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
 26c:	fc 01       	movw	r30, r24
 26e:	11 86       	std	Z+9, r1	; 0x09
 270:	10 86       	std	Z+8, r1	; 0x08
 272:	08 95       	ret

00000274 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 274:	cf 93       	push	r28
 276:	df 93       	push	r29
 278:	9c 01       	movw	r18, r24
 27a:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
 27c:	dc 01       	movw	r26, r24
 27e:	11 96       	adiw	r26, 0x01	; 1
 280:	cd 91       	ld	r28, X+
 282:	dc 91       	ld	r29, X
 284:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 286:	d3 83       	std	Z+3, r29	; 0x03
 288:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 28a:	8c 81       	ldd	r24, Y+4	; 0x04
 28c:	9d 81       	ldd	r25, Y+5	; 0x05
 28e:	95 83       	std	Z+5, r25	; 0x05
 290:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 292:	8c 81       	ldd	r24, Y+4	; 0x04
 294:	9d 81       	ldd	r25, Y+5	; 0x05
 296:	dc 01       	movw	r26, r24
 298:	13 96       	adiw	r26, 0x03	; 3
 29a:	7c 93       	st	X, r23
 29c:	6e 93       	st	-X, r22
 29e:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
 2a0:	7d 83       	std	Y+5, r23	; 0x05
 2a2:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
 2a4:	31 87       	std	Z+9, r19	; 0x09
 2a6:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
 2a8:	f9 01       	movw	r30, r18
 2aa:	80 81       	ld	r24, Z
 2ac:	8f 5f       	subi	r24, 0xFF	; 255
 2ae:	80 83       	st	Z, r24
}
 2b0:	df 91       	pop	r29
 2b2:	cf 91       	pop	r28
 2b4:	08 95       	ret

000002b6 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 2b6:	cf 93       	push	r28
 2b8:	df 93       	push	r29
 2ba:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 2bc:	48 81       	ld	r20, Y
 2be:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 2c0:	4f 3f       	cpi	r20, 0xFF	; 255
 2c2:	2f ef       	ldi	r18, 0xFF	; 255
 2c4:	52 07       	cpc	r21, r18
 2c6:	21 f4       	brne	.+8      	; 0x2d0 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 2c8:	fc 01       	movw	r30, r24
 2ca:	a7 81       	ldd	r26, Z+7	; 0x07
 2cc:	b0 85       	ldd	r27, Z+8	; 0x08
 2ce:	0d c0       	rjmp	.+26     	; 0x2ea <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 2d0:	dc 01       	movw	r26, r24
 2d2:	13 96       	adiw	r26, 0x03	; 3
 2d4:	01 c0       	rjmp	.+2      	; 0x2d8 <vListInsert+0x22>
 2d6:	df 01       	movw	r26, r30
 2d8:	12 96       	adiw	r26, 0x02	; 2
 2da:	ed 91       	ld	r30, X+
 2dc:	fc 91       	ld	r31, X
 2de:	13 97       	sbiw	r26, 0x03	; 3
 2e0:	20 81       	ld	r18, Z
 2e2:	31 81       	ldd	r19, Z+1	; 0x01
 2e4:	42 17       	cp	r20, r18
 2e6:	53 07       	cpc	r21, r19
 2e8:	b0 f7       	brcc	.-20     	; 0x2d6 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 2ea:	12 96       	adiw	r26, 0x02	; 2
 2ec:	ed 91       	ld	r30, X+
 2ee:	fc 91       	ld	r31, X
 2f0:	13 97       	sbiw	r26, 0x03	; 3
 2f2:	fb 83       	std	Y+3, r31	; 0x03
 2f4:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 2f6:	d5 83       	std	Z+5, r29	; 0x05
 2f8:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
 2fa:	bd 83       	std	Y+5, r27	; 0x05
 2fc:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
 2fe:	13 96       	adiw	r26, 0x03	; 3
 300:	dc 93       	st	X, r29
 302:	ce 93       	st	-X, r28
 304:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
 306:	99 87       	std	Y+9, r25	; 0x09
 308:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 30a:	fc 01       	movw	r30, r24
 30c:	20 81       	ld	r18, Z
 30e:	2f 5f       	subi	r18, 0xFF	; 255
 310:	20 83       	st	Z, r18
}
 312:	df 91       	pop	r29
 314:	cf 91       	pop	r28
 316:	08 95       	ret

00000318 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 318:	cf 93       	push	r28
 31a:	df 93       	push	r29
 31c:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
 31e:	a0 85       	ldd	r26, Z+8	; 0x08
 320:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 322:	c2 81       	ldd	r28, Z+2	; 0x02
 324:	d3 81       	ldd	r29, Z+3	; 0x03
 326:	84 81       	ldd	r24, Z+4	; 0x04
 328:	95 81       	ldd	r25, Z+5	; 0x05
 32a:	9d 83       	std	Y+5, r25	; 0x05
 32c:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 32e:	c4 81       	ldd	r28, Z+4	; 0x04
 330:	d5 81       	ldd	r29, Z+5	; 0x05
 332:	82 81       	ldd	r24, Z+2	; 0x02
 334:	93 81       	ldd	r25, Z+3	; 0x03
 336:	9b 83       	std	Y+3, r25	; 0x03
 338:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 33a:	11 96       	adiw	r26, 0x01	; 1
 33c:	8d 91       	ld	r24, X+
 33e:	9c 91       	ld	r25, X
 340:	12 97       	sbiw	r26, 0x02	; 2
 342:	e8 17       	cp	r30, r24
 344:	f9 07       	cpc	r31, r25
 346:	31 f4       	brne	.+12     	; 0x354 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 348:	84 81       	ldd	r24, Z+4	; 0x04
 34a:	95 81       	ldd	r25, Z+5	; 0x05
 34c:	12 96       	adiw	r26, 0x02	; 2
 34e:	9c 93       	st	X, r25
 350:	8e 93       	st	-X, r24
 352:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
 354:	11 86       	std	Z+9, r1	; 0x09
 356:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 358:	8c 91       	ld	r24, X
 35a:	81 50       	subi	r24, 0x01	; 1
 35c:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
 35e:	8c 91       	ld	r24, X
}
 360:	df 91       	pop	r29
 362:	cf 91       	pop	r28
 364:	08 95       	ret

00000366 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 366:	31 e1       	ldi	r19, 0x11	; 17
 368:	fc 01       	movw	r30, r24
 36a:	30 83       	st	Z, r19
 36c:	31 97       	sbiw	r30, 0x01	; 1
 36e:	22 e2       	ldi	r18, 0x22	; 34
 370:	20 83       	st	Z, r18
 372:	31 97       	sbiw	r30, 0x01	; 1
 374:	a3 e3       	ldi	r26, 0x33	; 51
 376:	a0 83       	st	Z, r26
 378:	31 97       	sbiw	r30, 0x01	; 1
 37a:	60 83       	st	Z, r22
 37c:	31 97       	sbiw	r30, 0x01	; 1
 37e:	70 83       	st	Z, r23
 380:	31 97       	sbiw	r30, 0x01	; 1
 382:	10 82       	st	Z, r1
 384:	31 97       	sbiw	r30, 0x01	; 1
 386:	60 e8       	ldi	r22, 0x80	; 128
 388:	60 83       	st	Z, r22
 38a:	31 97       	sbiw	r30, 0x01	; 1
 38c:	10 82       	st	Z, r1
 38e:	31 97       	sbiw	r30, 0x01	; 1
 390:	62 e0       	ldi	r22, 0x02	; 2
 392:	60 83       	st	Z, r22
 394:	31 97       	sbiw	r30, 0x01	; 1
 396:	63 e0       	ldi	r22, 0x03	; 3
 398:	60 83       	st	Z, r22
 39a:	31 97       	sbiw	r30, 0x01	; 1
 39c:	64 e0       	ldi	r22, 0x04	; 4
 39e:	60 83       	st	Z, r22
 3a0:	31 97       	sbiw	r30, 0x01	; 1
 3a2:	65 e0       	ldi	r22, 0x05	; 5
 3a4:	60 83       	st	Z, r22
 3a6:	31 97       	sbiw	r30, 0x01	; 1
 3a8:	66 e0       	ldi	r22, 0x06	; 6
 3aa:	60 83       	st	Z, r22
 3ac:	31 97       	sbiw	r30, 0x01	; 1
 3ae:	67 e0       	ldi	r22, 0x07	; 7
 3b0:	60 83       	st	Z, r22
 3b2:	31 97       	sbiw	r30, 0x01	; 1
 3b4:	68 e0       	ldi	r22, 0x08	; 8
 3b6:	60 83       	st	Z, r22
 3b8:	31 97       	sbiw	r30, 0x01	; 1
 3ba:	69 e0       	ldi	r22, 0x09	; 9
 3bc:	60 83       	st	Z, r22
 3be:	31 97       	sbiw	r30, 0x01	; 1
 3c0:	60 e1       	ldi	r22, 0x10	; 16
 3c2:	60 83       	st	Z, r22
 3c4:	31 97       	sbiw	r30, 0x01	; 1
 3c6:	30 83       	st	Z, r19
 3c8:	31 97       	sbiw	r30, 0x01	; 1
 3ca:	32 e1       	ldi	r19, 0x12	; 18
 3cc:	30 83       	st	Z, r19
 3ce:	31 97       	sbiw	r30, 0x01	; 1
 3d0:	33 e1       	ldi	r19, 0x13	; 19
 3d2:	30 83       	st	Z, r19
 3d4:	31 97       	sbiw	r30, 0x01	; 1
 3d6:	34 e1       	ldi	r19, 0x14	; 20
 3d8:	30 83       	st	Z, r19
 3da:	31 97       	sbiw	r30, 0x01	; 1
 3dc:	35 e1       	ldi	r19, 0x15	; 21
 3de:	30 83       	st	Z, r19
 3e0:	31 97       	sbiw	r30, 0x01	; 1
 3e2:	36 e1       	ldi	r19, 0x16	; 22
 3e4:	30 83       	st	Z, r19
 3e6:	31 97       	sbiw	r30, 0x01	; 1
 3e8:	37 e1       	ldi	r19, 0x17	; 23
 3ea:	30 83       	st	Z, r19
 3ec:	31 97       	sbiw	r30, 0x01	; 1
 3ee:	38 e1       	ldi	r19, 0x18	; 24
 3f0:	30 83       	st	Z, r19
 3f2:	31 97       	sbiw	r30, 0x01	; 1
 3f4:	39 e1       	ldi	r19, 0x19	; 25
 3f6:	30 83       	st	Z, r19
 3f8:	31 97       	sbiw	r30, 0x01	; 1
 3fa:	30 e2       	ldi	r19, 0x20	; 32
 3fc:	30 83       	st	Z, r19
 3fe:	31 97       	sbiw	r30, 0x01	; 1
 400:	31 e2       	ldi	r19, 0x21	; 33
 402:	30 83       	st	Z, r19
 404:	31 97       	sbiw	r30, 0x01	; 1
 406:	20 83       	st	Z, r18
 408:	31 97       	sbiw	r30, 0x01	; 1
 40a:	23 e2       	ldi	r18, 0x23	; 35
 40c:	20 83       	st	Z, r18
 40e:	31 97       	sbiw	r30, 0x01	; 1
 410:	40 83       	st	Z, r20
 412:	31 97       	sbiw	r30, 0x01	; 1
 414:	50 83       	st	Z, r21
 416:	31 97       	sbiw	r30, 0x01	; 1
 418:	26 e2       	ldi	r18, 0x26	; 38
 41a:	20 83       	st	Z, r18
 41c:	31 97       	sbiw	r30, 0x01	; 1
 41e:	27 e2       	ldi	r18, 0x27	; 39
 420:	20 83       	st	Z, r18
 422:	31 97       	sbiw	r30, 0x01	; 1
 424:	28 e2       	ldi	r18, 0x28	; 40
 426:	20 83       	st	Z, r18
 428:	31 97       	sbiw	r30, 0x01	; 1
 42a:	29 e2       	ldi	r18, 0x29	; 41
 42c:	20 83       	st	Z, r18
 42e:	31 97       	sbiw	r30, 0x01	; 1
 430:	20 e3       	ldi	r18, 0x30	; 48
 432:	20 83       	st	Z, r18
 434:	31 97       	sbiw	r30, 0x01	; 1
 436:	21 e3       	ldi	r18, 0x31	; 49
 438:	20 83       	st	Z, r18
 43a:	86 97       	sbiw	r24, 0x26	; 38
 43c:	08 95       	ret

0000043e <xPortStartScheduler>:
 43e:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
 442:	8c e7       	ldi	r24, 0x7C	; 124
 444:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
 448:	8b e0       	ldi	r24, 0x0B	; 11
 44a:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 44e:	ef e6       	ldi	r30, 0x6F	; 111
 450:	f0 e0       	ldi	r31, 0x00	; 0
 452:	80 81       	ld	r24, Z
 454:	82 60       	ori	r24, 0x02	; 2
 456:	80 83       	st	Z, r24
 458:	a0 91 57 07 	lds	r26, 0x0757	; 0x800757 <pxCurrentTCB>
 45c:	b0 91 58 07 	lds	r27, 0x0758	; 0x800758 <pxCurrentTCB+0x1>
 460:	cd 91       	ld	r28, X+
 462:	cd bf       	out	0x3d, r28	; 61
 464:	dd 91       	ld	r29, X+
 466:	de bf       	out	0x3e, r29	; 62
 468:	ff 91       	pop	r31
 46a:	ef 91       	pop	r30
 46c:	df 91       	pop	r29
 46e:	cf 91       	pop	r28
 470:	bf 91       	pop	r27
 472:	af 91       	pop	r26
 474:	9f 91       	pop	r25
 476:	8f 91       	pop	r24
 478:	7f 91       	pop	r23
 47a:	6f 91       	pop	r22
 47c:	5f 91       	pop	r21
 47e:	4f 91       	pop	r20
 480:	3f 91       	pop	r19
 482:	2f 91       	pop	r18
 484:	1f 91       	pop	r17
 486:	0f 91       	pop	r16
 488:	ff 90       	pop	r15
 48a:	ef 90       	pop	r14
 48c:	df 90       	pop	r13
 48e:	cf 90       	pop	r12
 490:	bf 90       	pop	r11
 492:	af 90       	pop	r10
 494:	9f 90       	pop	r9
 496:	8f 90       	pop	r8
 498:	7f 90       	pop	r7
 49a:	6f 90       	pop	r6
 49c:	5f 90       	pop	r5
 49e:	4f 90       	pop	r4
 4a0:	3f 90       	pop	r3
 4a2:	2f 90       	pop	r2
 4a4:	1f 90       	pop	r1
 4a6:	0f 90       	pop	r0
 4a8:	0f be       	out	0x3f, r0	; 63
 4aa:	0f 90       	pop	r0
 4ac:	08 95       	ret
 4ae:	81 e0       	ldi	r24, 0x01	; 1
 4b0:	08 95       	ret

000004b2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 4b2:	0f 92       	push	r0
 4b4:	0f b6       	in	r0, 0x3f	; 63
 4b6:	f8 94       	cli
 4b8:	0f 92       	push	r0
 4ba:	1f 92       	push	r1
 4bc:	11 24       	eor	r1, r1
 4be:	2f 92       	push	r2
 4c0:	3f 92       	push	r3
 4c2:	4f 92       	push	r4
 4c4:	5f 92       	push	r5
 4c6:	6f 92       	push	r6
 4c8:	7f 92       	push	r7
 4ca:	8f 92       	push	r8
 4cc:	9f 92       	push	r9
 4ce:	af 92       	push	r10
 4d0:	bf 92       	push	r11
 4d2:	cf 92       	push	r12
 4d4:	df 92       	push	r13
 4d6:	ef 92       	push	r14
 4d8:	ff 92       	push	r15
 4da:	0f 93       	push	r16
 4dc:	1f 93       	push	r17
 4de:	2f 93       	push	r18
 4e0:	3f 93       	push	r19
 4e2:	4f 93       	push	r20
 4e4:	5f 93       	push	r21
 4e6:	6f 93       	push	r22
 4e8:	7f 93       	push	r23
 4ea:	8f 93       	push	r24
 4ec:	9f 93       	push	r25
 4ee:	af 93       	push	r26
 4f0:	bf 93       	push	r27
 4f2:	cf 93       	push	r28
 4f4:	df 93       	push	r29
 4f6:	ef 93       	push	r30
 4f8:	ff 93       	push	r31
 4fa:	a0 91 57 07 	lds	r26, 0x0757	; 0x800757 <pxCurrentTCB>
 4fe:	b0 91 58 07 	lds	r27, 0x0758	; 0x800758 <pxCurrentTCB+0x1>
 502:	0d b6       	in	r0, 0x3d	; 61
 504:	0d 92       	st	X+, r0
 506:	0e b6       	in	r0, 0x3e	; 62
 508:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 50a:	86 d3       	rcall	.+1804   	; 0xc18 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 50c:	a0 91 57 07 	lds	r26, 0x0757	; 0x800757 <pxCurrentTCB>
 510:	b0 91 58 07 	lds	r27, 0x0758	; 0x800758 <pxCurrentTCB+0x1>
 514:	cd 91       	ld	r28, X+
 516:	cd bf       	out	0x3d, r28	; 61
 518:	dd 91       	ld	r29, X+
 51a:	de bf       	out	0x3e, r29	; 62
 51c:	ff 91       	pop	r31
 51e:	ef 91       	pop	r30
 520:	df 91       	pop	r29
 522:	cf 91       	pop	r28
 524:	bf 91       	pop	r27
 526:	af 91       	pop	r26
 528:	9f 91       	pop	r25
 52a:	8f 91       	pop	r24
 52c:	7f 91       	pop	r23
 52e:	6f 91       	pop	r22
 530:	5f 91       	pop	r21
 532:	4f 91       	pop	r20
 534:	3f 91       	pop	r19
 536:	2f 91       	pop	r18
 538:	1f 91       	pop	r17
 53a:	0f 91       	pop	r16
 53c:	ff 90       	pop	r15
 53e:	ef 90       	pop	r14
 540:	df 90       	pop	r13
 542:	cf 90       	pop	r12
 544:	bf 90       	pop	r11
 546:	af 90       	pop	r10
 548:	9f 90       	pop	r9
 54a:	8f 90       	pop	r8
 54c:	7f 90       	pop	r7
 54e:	6f 90       	pop	r6
 550:	5f 90       	pop	r5
 552:	4f 90       	pop	r4
 554:	3f 90       	pop	r3
 556:	2f 90       	pop	r2
 558:	1f 90       	pop	r1
 55a:	0f 90       	pop	r0
 55c:	0f be       	out	0x3f, r0	; 63
 55e:	0f 90       	pop	r0

	asm volatile ( "ret" );
 560:	08 95       	ret

00000562 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 562:	0f 92       	push	r0
 564:	0f b6       	in	r0, 0x3f	; 63
 566:	f8 94       	cli
 568:	0f 92       	push	r0
 56a:	1f 92       	push	r1
 56c:	11 24       	eor	r1, r1
 56e:	2f 92       	push	r2
 570:	3f 92       	push	r3
 572:	4f 92       	push	r4
 574:	5f 92       	push	r5
 576:	6f 92       	push	r6
 578:	7f 92       	push	r7
 57a:	8f 92       	push	r8
 57c:	9f 92       	push	r9
 57e:	af 92       	push	r10
 580:	bf 92       	push	r11
 582:	cf 92       	push	r12
 584:	df 92       	push	r13
 586:	ef 92       	push	r14
 588:	ff 92       	push	r15
 58a:	0f 93       	push	r16
 58c:	1f 93       	push	r17
 58e:	2f 93       	push	r18
 590:	3f 93       	push	r19
 592:	4f 93       	push	r20
 594:	5f 93       	push	r21
 596:	6f 93       	push	r22
 598:	7f 93       	push	r23
 59a:	8f 93       	push	r24
 59c:	9f 93       	push	r25
 59e:	af 93       	push	r26
 5a0:	bf 93       	push	r27
 5a2:	cf 93       	push	r28
 5a4:	df 93       	push	r29
 5a6:	ef 93       	push	r30
 5a8:	ff 93       	push	r31
 5aa:	a0 91 57 07 	lds	r26, 0x0757	; 0x800757 <pxCurrentTCB>
 5ae:	b0 91 58 07 	lds	r27, 0x0758	; 0x800758 <pxCurrentTCB+0x1>
 5b2:	0d b6       	in	r0, 0x3d	; 61
 5b4:	0d 92       	st	X+, r0
 5b6:	0e b6       	in	r0, 0x3e	; 62
 5b8:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
 5ba:	ee d1       	rcall	.+988    	; 0x998 <xTaskIncrementTick>
 5bc:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
 5be:	2c d3       	rcall	.+1624   	; 0xc18 <vTaskSwitchContext>
 5c0:	a0 91 57 07 	lds	r26, 0x0757	; 0x800757 <pxCurrentTCB>
	}
	portRESTORE_CONTEXT();
 5c4:	b0 91 58 07 	lds	r27, 0x0758	; 0x800758 <pxCurrentTCB+0x1>
 5c8:	cd 91       	ld	r28, X+
 5ca:	cd bf       	out	0x3d, r28	; 61
 5cc:	dd 91       	ld	r29, X+
 5ce:	de bf       	out	0x3e, r29	; 62
 5d0:	ff 91       	pop	r31
 5d2:	ef 91       	pop	r30
 5d4:	df 91       	pop	r29
 5d6:	cf 91       	pop	r28
 5d8:	bf 91       	pop	r27
 5da:	af 91       	pop	r26
 5dc:	9f 91       	pop	r25
 5de:	8f 91       	pop	r24
 5e0:	7f 91       	pop	r23
 5e2:	6f 91       	pop	r22
 5e4:	5f 91       	pop	r21
 5e6:	4f 91       	pop	r20
 5e8:	3f 91       	pop	r19
 5ea:	2f 91       	pop	r18
 5ec:	1f 91       	pop	r17
 5ee:	0f 91       	pop	r16
 5f0:	ff 90       	pop	r15
 5f2:	ef 90       	pop	r14
 5f4:	df 90       	pop	r13
 5f6:	cf 90       	pop	r12
 5f8:	bf 90       	pop	r11
 5fa:	af 90       	pop	r10
 5fc:	9f 90       	pop	r9
 5fe:	8f 90       	pop	r8
 600:	7f 90       	pop	r7
 602:	6f 90       	pop	r6
 604:	5f 90       	pop	r5
 606:	4f 90       	pop	r4
 608:	3f 90       	pop	r3
 60a:	2f 90       	pop	r2
 60c:	1f 90       	pop	r1
 60e:	0f 90       	pop	r0
 610:	0f be       	out	0x3f, r0	; 63
 612:	0f 90       	pop	r0
 614:	08 95       	ret

00000616 <__vector_13>:

	asm volatile ( "ret" );
 616:	a5 df       	rcall	.-182    	; 0x562 <vPortYieldFromTick>
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
		asm volatile ( "reti" );
 618:	18 95       	reti

0000061a <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 61a:	e0 91 1f 07 	lds	r30, 0x071F	; 0x80071f <pxDelayedTaskList>
 61e:	f0 91 20 07 	lds	r31, 0x0720	; 0x800720 <pxDelayedTaskList+0x1>
 622:	80 81       	ld	r24, Z
 624:	81 11       	cpse	r24, r1
 626:	07 c0       	rjmp	.+14     	; 0x636 <prvResetNextTaskUnblockTime+0x1c>
 628:	8f ef       	ldi	r24, 0xFF	; 255
 62a:	9f ef       	ldi	r25, 0xFF	; 255
 62c:	90 93 00 07 	sts	0x0700, r25	; 0x800700 <xNextTaskUnblockTime+0x1>
 630:	80 93 ff 06 	sts	0x06FF, r24	; 0x8006ff <xNextTaskUnblockTime>
 634:	08 95       	ret
 636:	e0 91 1f 07 	lds	r30, 0x071F	; 0x80071f <pxDelayedTaskList>
 63a:	f0 91 20 07 	lds	r31, 0x0720	; 0x800720 <pxDelayedTaskList+0x1>
 63e:	05 80       	ldd	r0, Z+5	; 0x05
 640:	f6 81       	ldd	r31, Z+6	; 0x06
 642:	e0 2d       	mov	r30, r0
 644:	06 80       	ldd	r0, Z+6	; 0x06
 646:	f7 81       	ldd	r31, Z+7	; 0x07
 648:	e0 2d       	mov	r30, r0
 64a:	82 81       	ldd	r24, Z+2	; 0x02
 64c:	93 81       	ldd	r25, Z+3	; 0x03
 64e:	90 93 00 07 	sts	0x0700, r25	; 0x800700 <xNextTaskUnblockTime+0x1>
 652:	80 93 ff 06 	sts	0x06FF, r24	; 0x8006ff <xNextTaskUnblockTime>
 656:	08 95       	ret

00000658 <prvIdleTask>:
 658:	0b e0       	ldi	r16, 0x0B	; 11
 65a:	17 e0       	ldi	r17, 0x07	; 7
 65c:	0f 2e       	mov	r0, r31
 65e:	f3 e3       	ldi	r31, 0x33	; 51
 660:	ef 2e       	mov	r14, r31
 662:	f7 e0       	ldi	r31, 0x07	; 7
 664:	ff 2e       	mov	r15, r31
 666:	f0 2d       	mov	r31, r0
 668:	80 91 0a 07 	lds	r24, 0x070A	; 0x80070a <uxDeletedTasksWaitingCleanUp>
 66c:	88 23       	and	r24, r24
 66e:	11 f1       	breq	.+68     	; 0x6b4 <prvIdleTask+0x5c>
 670:	0f b6       	in	r0, 0x3f	; 63
 672:	f8 94       	cli
 674:	0f 92       	push	r0
 676:	d8 01       	movw	r26, r16
 678:	15 96       	adiw	r26, 0x05	; 5
 67a:	ed 91       	ld	r30, X+
 67c:	fc 91       	ld	r31, X
 67e:	16 97       	sbiw	r26, 0x06	; 6
 680:	c6 81       	ldd	r28, Z+6	; 0x06
 682:	d7 81       	ldd	r29, Z+7	; 0x07
 684:	ce 01       	movw	r24, r28
 686:	02 96       	adiw	r24, 0x02	; 2
 688:	47 de       	rcall	.-882    	; 0x318 <uxListRemove>
 68a:	80 91 09 07 	lds	r24, 0x0709	; 0x800709 <uxCurrentNumberOfTasks>
 68e:	81 50       	subi	r24, 0x01	; 1
 690:	80 93 09 07 	sts	0x0709, r24	; 0x800709 <uxCurrentNumberOfTasks>
 694:	80 91 0a 07 	lds	r24, 0x070A	; 0x80070a <uxDeletedTasksWaitingCleanUp>
 698:	81 50       	subi	r24, 0x01	; 1
 69a:	80 93 0a 07 	sts	0x070A, r24	; 0x80070a <uxDeletedTasksWaitingCleanUp>
 69e:	0f 90       	pop	r0
 6a0:	0f be       	out	0x3f, r0	; 63
 6a2:	8f 89       	ldd	r24, Y+23	; 0x17
 6a4:	98 8d       	ldd	r25, Y+24	; 0x18
 6a6:	d3 dd       	rcall	.-1114   	; 0x24e <vPortFree>
 6a8:	ce 01       	movw	r24, r28
 6aa:	d1 dd       	rcall	.-1118   	; 0x24e <vPortFree>
 6ac:	80 91 0a 07 	lds	r24, 0x070A	; 0x80070a <uxDeletedTasksWaitingCleanUp>
 6b0:	81 11       	cpse	r24, r1
 6b2:	de cf       	rjmp	.-68     	; 0x670 <prvIdleTask+0x18>
 6b4:	f7 01       	movw	r30, r14
 6b6:	80 81       	ld	r24, Z
 6b8:	82 30       	cpi	r24, 0x02	; 2
 6ba:	b0 f2       	brcs	.-84     	; 0x668 <prvIdleTask+0x10>
 6bc:	fa de       	rcall	.-524    	; 0x4b2 <vPortYield>
 6be:	d4 cf       	rjmp	.-88     	; 0x668 <prvIdleTask+0x10>

000006c0 <prvAddCurrentTaskToDelayedList>:
 6c0:	0f 93       	push	r16
 6c2:	1f 93       	push	r17
 6c4:	cf 93       	push	r28
 6c6:	df 93       	push	r29
 6c8:	ec 01       	movw	r28, r24
 6ca:	00 91 07 07 	lds	r16, 0x0707	; 0x800707 <xTickCount>
 6ce:	10 91 08 07 	lds	r17, 0x0708	; 0x800708 <xTickCount+0x1>
 6d2:	80 91 57 07 	lds	r24, 0x0757	; 0x800757 <pxCurrentTCB>
 6d6:	90 91 58 07 	lds	r25, 0x0758	; 0x800758 <pxCurrentTCB+0x1>
 6da:	02 96       	adiw	r24, 0x02	; 2
 6dc:	1d de       	rcall	.-966    	; 0x318 <uxListRemove>
 6de:	c0 0f       	add	r28, r16
 6e0:	d1 1f       	adc	r29, r17
 6e2:	e0 91 57 07 	lds	r30, 0x0757	; 0x800757 <pxCurrentTCB>
 6e6:	f0 91 58 07 	lds	r31, 0x0758	; 0x800758 <pxCurrentTCB+0x1>
 6ea:	d3 83       	std	Z+3, r29	; 0x03
 6ec:	c2 83       	std	Z+2, r28	; 0x02
 6ee:	c0 17       	cp	r28, r16
 6f0:	d1 07       	cpc	r29, r17
 6f2:	60 f4       	brcc	.+24     	; 0x70c <prvAddCurrentTaskToDelayedList+0x4c>
 6f4:	60 91 57 07 	lds	r22, 0x0757	; 0x800757 <pxCurrentTCB>
 6f8:	70 91 58 07 	lds	r23, 0x0758	; 0x800758 <pxCurrentTCB+0x1>
 6fc:	80 91 1d 07 	lds	r24, 0x071D	; 0x80071d <pxOverflowDelayedTaskList>
 700:	90 91 1e 07 	lds	r25, 0x071E	; 0x80071e <pxOverflowDelayedTaskList+0x1>
 704:	6e 5f       	subi	r22, 0xFE	; 254
 706:	7f 4f       	sbci	r23, 0xFF	; 255
 708:	d6 dd       	rcall	.-1108   	; 0x2b6 <vListInsert>
 70a:	16 c0       	rjmp	.+44     	; 0x738 <prvAddCurrentTaskToDelayedList+0x78>
 70c:	60 91 57 07 	lds	r22, 0x0757	; 0x800757 <pxCurrentTCB>
 710:	70 91 58 07 	lds	r23, 0x0758	; 0x800758 <pxCurrentTCB+0x1>
 714:	80 91 1f 07 	lds	r24, 0x071F	; 0x80071f <pxDelayedTaskList>
 718:	90 91 20 07 	lds	r25, 0x0720	; 0x800720 <pxDelayedTaskList+0x1>
 71c:	6e 5f       	subi	r22, 0xFE	; 254
 71e:	7f 4f       	sbci	r23, 0xFF	; 255
 720:	ca dd       	rcall	.-1132   	; 0x2b6 <vListInsert>
 722:	80 91 ff 06 	lds	r24, 0x06FF	; 0x8006ff <xNextTaskUnblockTime>
 726:	90 91 00 07 	lds	r25, 0x0700	; 0x800700 <xNextTaskUnblockTime+0x1>
 72a:	c8 17       	cp	r28, r24
 72c:	d9 07       	cpc	r29, r25
 72e:	20 f4       	brcc	.+8      	; 0x738 <prvAddCurrentTaskToDelayedList+0x78>
 730:	d0 93 00 07 	sts	0x0700, r29	; 0x800700 <xNextTaskUnblockTime+0x1>
 734:	c0 93 ff 06 	sts	0x06FF, r28	; 0x8006ff <xNextTaskUnblockTime>
 738:	df 91       	pop	r29
 73a:	cf 91       	pop	r28
 73c:	1f 91       	pop	r17
 73e:	0f 91       	pop	r16
 740:	08 95       	ret

00000742 <xTaskCreate>:
 742:	4f 92       	push	r4
 744:	5f 92       	push	r5
 746:	6f 92       	push	r6
 748:	7f 92       	push	r7
 74a:	8f 92       	push	r8
 74c:	9f 92       	push	r9
 74e:	af 92       	push	r10
 750:	bf 92       	push	r11
 752:	cf 92       	push	r12
 754:	df 92       	push	r13
 756:	ef 92       	push	r14
 758:	ff 92       	push	r15
 75a:	0f 93       	push	r16
 75c:	cf 93       	push	r28
 75e:	df 93       	push	r29
 760:	4c 01       	movw	r8, r24
 762:	6b 01       	movw	r12, r22
 764:	5a 01       	movw	r10, r20
 766:	29 01       	movw	r4, r18
 768:	ca 01       	movw	r24, r20
 76a:	3e dd       	rcall	.-1412   	; 0x1e8 <pvPortMalloc>
 76c:	3c 01       	movw	r6, r24
 76e:	89 2b       	or	r24, r25
 770:	09 f4       	brne	.+2      	; 0x774 <xTaskCreate+0x32>
 772:	d3 c0       	rjmp	.+422    	; 0x91a <xTaskCreate+0x1d8>
 774:	86 e2       	ldi	r24, 0x26	; 38
 776:	90 e0       	ldi	r25, 0x00	; 0
 778:	37 dd       	rcall	.-1426   	; 0x1e8 <pvPortMalloc>
 77a:	ec 01       	movw	r28, r24
 77c:	89 2b       	or	r24, r25
 77e:	59 f0       	breq	.+22     	; 0x796 <xTaskCreate+0x54>
 780:	78 8e       	std	Y+24, r7	; 0x18
 782:	6f 8a       	std	Y+23, r6	; 0x17
 784:	81 e0       	ldi	r24, 0x01	; 1
 786:	a8 1a       	sub	r10, r24
 788:	b1 08       	sbc	r11, r1
 78a:	a6 0c       	add	r10, r6
 78c:	b7 1c       	adc	r11, r7
 78e:	c1 14       	cp	r12, r1
 790:	d1 04       	cpc	r13, r1
 792:	21 f4       	brne	.+8      	; 0x79c <xTaskCreate+0x5a>
 794:	1f c0       	rjmp	.+62     	; 0x7d4 <xTaskCreate+0x92>
 796:	c3 01       	movw	r24, r6
 798:	5a dd       	rcall	.-1356   	; 0x24e <vPortFree>
 79a:	bf c0       	rjmp	.+382    	; 0x91a <xTaskCreate+0x1d8>
 79c:	d6 01       	movw	r26, r12
 79e:	8c 91       	ld	r24, X
 7a0:	89 8f       	std	Y+25, r24	; 0x19
 7a2:	8c 91       	ld	r24, X
 7a4:	88 23       	and	r24, r24
 7a6:	a1 f0       	breq	.+40     	; 0x7d0 <xTaskCreate+0x8e>
 7a8:	ae 01       	movw	r20, r28
 7aa:	46 5e       	subi	r20, 0xE6	; 230
 7ac:	5f 4f       	sbci	r21, 0xFF	; 255
 7ae:	f6 01       	movw	r30, r12
 7b0:	31 96       	adiw	r30, 0x01	; 1
 7b2:	b8 e0       	ldi	r27, 0x08	; 8
 7b4:	cb 0e       	add	r12, r27
 7b6:	d1 1c       	adc	r13, r1
 7b8:	cf 01       	movw	r24, r30
 7ba:	21 91       	ld	r18, Z+
 7bc:	da 01       	movw	r26, r20
 7be:	2d 93       	st	X+, r18
 7c0:	ad 01       	movw	r20, r26
 7c2:	dc 01       	movw	r26, r24
 7c4:	8c 91       	ld	r24, X
 7c6:	88 23       	and	r24, r24
 7c8:	19 f0       	breq	.+6      	; 0x7d0 <xTaskCreate+0x8e>
 7ca:	ec 15       	cp	r30, r12
 7cc:	fd 05       	cpc	r31, r13
 7ce:	a1 f7       	brne	.-24     	; 0x7b8 <xTaskCreate+0x76>
 7d0:	18 a2       	std	Y+32, r1	; 0x20
 7d2:	01 c0       	rjmp	.+2      	; 0x7d6 <xTaskCreate+0x94>
 7d4:	19 8e       	std	Y+25, r1	; 0x19
 7d6:	04 30       	cpi	r16, 0x04	; 4
 7d8:	08 f0       	brcs	.+2      	; 0x7dc <xTaskCreate+0x9a>
 7da:	03 e0       	ldi	r16, 0x03	; 3
 7dc:	0e 8b       	std	Y+22, r16	; 0x16
 7de:	6e 01       	movw	r12, r28
 7e0:	b2 e0       	ldi	r27, 0x02	; 2
 7e2:	cb 0e       	add	r12, r27
 7e4:	d1 1c       	adc	r13, r1
 7e6:	c6 01       	movw	r24, r12
 7e8:	41 dd       	rcall	.-1406   	; 0x26c <vListInitialiseItem>
 7ea:	ce 01       	movw	r24, r28
 7ec:	0c 96       	adiw	r24, 0x0c	; 12
 7ee:	3e dd       	rcall	.-1412   	; 0x26c <vListInitialiseItem>
 7f0:	d9 87       	std	Y+9, r29	; 0x09
 7f2:	c8 87       	std	Y+8, r28	; 0x08
 7f4:	84 e0       	ldi	r24, 0x04	; 4
 7f6:	90 e0       	ldi	r25, 0x00	; 0
 7f8:	80 1b       	sub	r24, r16
 7fa:	91 09       	sbc	r25, r1
 7fc:	9d 87       	std	Y+13, r25	; 0x0d
 7fe:	8c 87       	std	Y+12, r24	; 0x0c
 800:	db 8b       	std	Y+19, r29	; 0x13
 802:	ca 8b       	std	Y+18, r28	; 0x12
 804:	19 a2       	std	Y+33, r1	; 0x21
 806:	1a a2       	std	Y+34, r1	; 0x22
 808:	1b a2       	std	Y+35, r1	; 0x23
 80a:	1c a2       	std	Y+36, r1	; 0x24
 80c:	1d a2       	std	Y+37, r1	; 0x25
 80e:	a2 01       	movw	r20, r4
 810:	b4 01       	movw	r22, r8
 812:	c5 01       	movw	r24, r10
 814:	a8 dd       	rcall	.-1200   	; 0x366 <pxPortInitialiseStack>
 816:	99 83       	std	Y+1, r25	; 0x01
 818:	88 83       	st	Y, r24
 81a:	e1 14       	cp	r14, r1
 81c:	f1 04       	cpc	r15, r1
 81e:	19 f0       	breq	.+6      	; 0x826 <xTaskCreate+0xe4>
 820:	f7 01       	movw	r30, r14
 822:	d1 83       	std	Z+1, r29	; 0x01
 824:	c0 83       	st	Z, r28
 826:	0f b6       	in	r0, 0x3f	; 63
 828:	f8 94       	cli
 82a:	0f 92       	push	r0
 82c:	80 91 09 07 	lds	r24, 0x0709	; 0x800709 <uxCurrentNumberOfTasks>
 830:	8f 5f       	subi	r24, 0xFF	; 255
 832:	80 93 09 07 	sts	0x0709, r24	; 0x800709 <uxCurrentNumberOfTasks>
 836:	80 91 57 07 	lds	r24, 0x0757	; 0x800757 <pxCurrentTCB>
 83a:	90 91 58 07 	lds	r25, 0x0758	; 0x800758 <pxCurrentTCB+0x1>
 83e:	89 2b       	or	r24, r25
 840:	69 f5       	brne	.+90     	; 0x89c <xTaskCreate+0x15a>
 842:	d0 93 58 07 	sts	0x0758, r29	; 0x800758 <pxCurrentTCB+0x1>
 846:	c0 93 57 07 	sts	0x0757, r28	; 0x800757 <pxCurrentTCB>
 84a:	80 91 09 07 	lds	r24, 0x0709	; 0x800709 <uxCurrentNumberOfTasks>
 84e:	81 30       	cpi	r24, 0x01	; 1
 850:	a9 f5       	brne	.+106    	; 0x8bc <xTaskCreate+0x17a>
 852:	83 e3       	ldi	r24, 0x33	; 51
 854:	97 e0       	ldi	r25, 0x07	; 7
 856:	fc dc       	rcall	.-1544   	; 0x250 <vListInitialise>
 858:	8c e3       	ldi	r24, 0x3C	; 60
 85a:	97 e0       	ldi	r25, 0x07	; 7
 85c:	f9 dc       	rcall	.-1550   	; 0x250 <vListInitialise>
 85e:	85 e4       	ldi	r24, 0x45	; 69
 860:	97 e0       	ldi	r25, 0x07	; 7
 862:	f6 dc       	rcall	.-1556   	; 0x250 <vListInitialise>
 864:	8e e4       	ldi	r24, 0x4E	; 78
 866:	97 e0       	ldi	r25, 0x07	; 7
 868:	f3 dc       	rcall	.-1562   	; 0x250 <vListInitialise>
 86a:	8a e2       	ldi	r24, 0x2A	; 42
 86c:	97 e0       	ldi	r25, 0x07	; 7
 86e:	f0 dc       	rcall	.-1568   	; 0x250 <vListInitialise>
 870:	81 e2       	ldi	r24, 0x21	; 33
 872:	97 e0       	ldi	r25, 0x07	; 7
 874:	ed dc       	rcall	.-1574   	; 0x250 <vListInitialise>
 876:	84 e1       	ldi	r24, 0x14	; 20
 878:	97 e0       	ldi	r25, 0x07	; 7
 87a:	ea dc       	rcall	.-1580   	; 0x250 <vListInitialise>
 87c:	8b e0       	ldi	r24, 0x0B	; 11
 87e:	97 e0       	ldi	r25, 0x07	; 7
 880:	e7 dc       	rcall	.-1586   	; 0x250 <vListInitialise>
 882:	8a e2       	ldi	r24, 0x2A	; 42
 884:	97 e0       	ldi	r25, 0x07	; 7
 886:	90 93 20 07 	sts	0x0720, r25	; 0x800720 <pxDelayedTaskList+0x1>
 88a:	80 93 1f 07 	sts	0x071F, r24	; 0x80071f <pxDelayedTaskList>
 88e:	81 e2       	ldi	r24, 0x21	; 33
 890:	97 e0       	ldi	r25, 0x07	; 7
 892:	90 93 1e 07 	sts	0x071E, r25	; 0x80071e <pxOverflowDelayedTaskList+0x1>
 896:	80 93 1d 07 	sts	0x071D, r24	; 0x80071d <pxOverflowDelayedTaskList>
 89a:	10 c0       	rjmp	.+32     	; 0x8bc <xTaskCreate+0x17a>
 89c:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <xSchedulerRunning>
 8a0:	81 11       	cpse	r24, r1
 8a2:	0c c0       	rjmp	.+24     	; 0x8bc <xTaskCreate+0x17a>
 8a4:	e0 91 57 07 	lds	r30, 0x0757	; 0x800757 <pxCurrentTCB>
 8a8:	f0 91 58 07 	lds	r31, 0x0758	; 0x800758 <pxCurrentTCB+0x1>
 8ac:	96 89       	ldd	r25, Z+22	; 0x16
 8ae:	8e 89       	ldd	r24, Y+22	; 0x16
 8b0:	89 17       	cp	r24, r25
 8b2:	20 f0       	brcs	.+8      	; 0x8bc <xTaskCreate+0x17a>
 8b4:	d0 93 58 07 	sts	0x0758, r29	; 0x800758 <pxCurrentTCB+0x1>
 8b8:	c0 93 57 07 	sts	0x0757, r28	; 0x800757 <pxCurrentTCB>
 8bc:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <uxTaskNumber>
 8c0:	8f 5f       	subi	r24, 0xFF	; 255
 8c2:	80 93 01 07 	sts	0x0701, r24	; 0x800701 <uxTaskNumber>
 8c6:	8e 89       	ldd	r24, Y+22	; 0x16
 8c8:	90 91 06 07 	lds	r25, 0x0706	; 0x800706 <uxTopReadyPriority>
 8cc:	98 17       	cp	r25, r24
 8ce:	10 f4       	brcc	.+4      	; 0x8d4 <xTaskCreate+0x192>
 8d0:	80 93 06 07 	sts	0x0706, r24	; 0x800706 <uxTopReadyPriority>
 8d4:	90 e0       	ldi	r25, 0x00	; 0
 8d6:	9c 01       	movw	r18, r24
 8d8:	22 0f       	add	r18, r18
 8da:	33 1f       	adc	r19, r19
 8dc:	22 0f       	add	r18, r18
 8de:	33 1f       	adc	r19, r19
 8e0:	22 0f       	add	r18, r18
 8e2:	33 1f       	adc	r19, r19
 8e4:	82 0f       	add	r24, r18
 8e6:	93 1f       	adc	r25, r19
 8e8:	b6 01       	movw	r22, r12
 8ea:	8d 5c       	subi	r24, 0xCD	; 205
 8ec:	98 4f       	sbci	r25, 0xF8	; 248
 8ee:	c2 dc       	rcall	.-1660   	; 0x274 <vListInsertEnd>
 8f0:	0f 90       	pop	r0
 8f2:	0f be       	out	0x3f, r0	; 63
 8f4:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <xSchedulerRunning>
 8f8:	88 23       	and	r24, r24
 8fa:	59 f0       	breq	.+22     	; 0x912 <xTaskCreate+0x1d0>
 8fc:	e0 91 57 07 	lds	r30, 0x0757	; 0x800757 <pxCurrentTCB>
 900:	f0 91 58 07 	lds	r31, 0x0758	; 0x800758 <pxCurrentTCB+0x1>
 904:	96 89       	ldd	r25, Z+22	; 0x16
 906:	8e 89       	ldd	r24, Y+22	; 0x16
 908:	98 17       	cp	r25, r24
 90a:	28 f4       	brcc	.+10     	; 0x916 <xTaskCreate+0x1d4>
 90c:	d2 dd       	rcall	.-1116   	; 0x4b2 <vPortYield>
 90e:	81 e0       	ldi	r24, 0x01	; 1
 910:	05 c0       	rjmp	.+10     	; 0x91c <xTaskCreate+0x1da>
 912:	81 e0       	ldi	r24, 0x01	; 1
 914:	03 c0       	rjmp	.+6      	; 0x91c <xTaskCreate+0x1da>
 916:	81 e0       	ldi	r24, 0x01	; 1
 918:	01 c0       	rjmp	.+2      	; 0x91c <xTaskCreate+0x1da>
 91a:	8f ef       	ldi	r24, 0xFF	; 255
 91c:	df 91       	pop	r29
 91e:	cf 91       	pop	r28
 920:	0f 91       	pop	r16
 922:	ff 90       	pop	r15
 924:	ef 90       	pop	r14
 926:	df 90       	pop	r13
 928:	cf 90       	pop	r12
 92a:	bf 90       	pop	r11
 92c:	af 90       	pop	r10
 92e:	9f 90       	pop	r9
 930:	8f 90       	pop	r8
 932:	7f 90       	pop	r7
 934:	6f 90       	pop	r6
 936:	5f 90       	pop	r5
 938:	4f 90       	pop	r4
 93a:	08 95       	ret

0000093c <vTaskStartScheduler>:
 93c:	ef 92       	push	r14
 93e:	ff 92       	push	r15
 940:	0f 93       	push	r16
 942:	0f 2e       	mov	r0, r31
 944:	fd ef       	ldi	r31, 0xFD	; 253
 946:	ef 2e       	mov	r14, r31
 948:	f6 e0       	ldi	r31, 0x06	; 6
 94a:	ff 2e       	mov	r15, r31
 94c:	f0 2d       	mov	r31, r0
 94e:	00 e0       	ldi	r16, 0x00	; 0
 950:	20 e0       	ldi	r18, 0x00	; 0
 952:	30 e0       	ldi	r19, 0x00	; 0
 954:	45 e5       	ldi	r20, 0x55	; 85
 956:	50 e0       	ldi	r21, 0x00	; 0
 958:	67 e1       	ldi	r22, 0x17	; 23
 95a:	71 e0       	ldi	r23, 0x01	; 1
 95c:	8c e2       	ldi	r24, 0x2C	; 44
 95e:	93 e0       	ldi	r25, 0x03	; 3
 960:	f0 de       	rcall	.-544    	; 0x742 <xTaskCreate>
 962:	81 30       	cpi	r24, 0x01	; 1
 964:	79 f4       	brne	.+30     	; 0x984 <vTaskStartScheduler+0x48>
 966:	f8 94       	cli
 968:	8f ef       	ldi	r24, 0xFF	; 255
 96a:	9f ef       	ldi	r25, 0xFF	; 255
 96c:	90 93 00 07 	sts	0x0700, r25	; 0x800700 <xNextTaskUnblockTime+0x1>
 970:	80 93 ff 06 	sts	0x06FF, r24	; 0x8006ff <xNextTaskUnblockTime>
 974:	81 e0       	ldi	r24, 0x01	; 1
 976:	80 93 05 07 	sts	0x0705, r24	; 0x800705 <xSchedulerRunning>
 97a:	10 92 08 07 	sts	0x0708, r1	; 0x800708 <xTickCount+0x1>
 97e:	10 92 07 07 	sts	0x0707, r1	; 0x800707 <xTickCount>
 982:	5d dd       	rcall	.-1350   	; 0x43e <xPortStartScheduler>
 984:	0f 91       	pop	r16
 986:	ff 90       	pop	r15
 988:	ef 90       	pop	r14
 98a:	08 95       	ret

0000098c <vTaskSuspendAll>:
 98c:	80 91 fc 06 	lds	r24, 0x06FC	; 0x8006fc <uxSchedulerSuspended>
 990:	8f 5f       	subi	r24, 0xFF	; 255
 992:	80 93 fc 06 	sts	0x06FC, r24	; 0x8006fc <uxSchedulerSuspended>
 996:	08 95       	ret

00000998 <xTaskIncrementTick>:
 998:	cf 92       	push	r12
 99a:	df 92       	push	r13
 99c:	ef 92       	push	r14
 99e:	ff 92       	push	r15
 9a0:	0f 93       	push	r16
 9a2:	1f 93       	push	r17
 9a4:	cf 93       	push	r28
 9a6:	df 93       	push	r29
 9a8:	80 91 fc 06 	lds	r24, 0x06FC	; 0x8006fc <uxSchedulerSuspended>
 9ac:	81 11       	cpse	r24, r1
 9ae:	95 c0       	rjmp	.+298    	; 0xada <xTaskIncrementTick+0x142>
 9b0:	e0 90 07 07 	lds	r14, 0x0707	; 0x800707 <xTickCount>
 9b4:	f0 90 08 07 	lds	r15, 0x0708	; 0x800708 <xTickCount+0x1>
 9b8:	8f ef       	ldi	r24, 0xFF	; 255
 9ba:	e8 1a       	sub	r14, r24
 9bc:	f8 0a       	sbc	r15, r24
 9be:	f0 92 08 07 	sts	0x0708, r15	; 0x800708 <xTickCount+0x1>
 9c2:	e0 92 07 07 	sts	0x0707, r14	; 0x800707 <xTickCount>
 9c6:	e1 14       	cp	r14, r1
 9c8:	f1 04       	cpc	r15, r1
 9ca:	b1 f4       	brne	.+44     	; 0x9f8 <xTaskIncrementTick+0x60>
 9cc:	80 91 1f 07 	lds	r24, 0x071F	; 0x80071f <pxDelayedTaskList>
 9d0:	90 91 20 07 	lds	r25, 0x0720	; 0x800720 <pxDelayedTaskList+0x1>
 9d4:	20 91 1d 07 	lds	r18, 0x071D	; 0x80071d <pxOverflowDelayedTaskList>
 9d8:	30 91 1e 07 	lds	r19, 0x071E	; 0x80071e <pxOverflowDelayedTaskList+0x1>
 9dc:	30 93 20 07 	sts	0x0720, r19	; 0x800720 <pxDelayedTaskList+0x1>
 9e0:	20 93 1f 07 	sts	0x071F, r18	; 0x80071f <pxDelayedTaskList>
 9e4:	90 93 1e 07 	sts	0x071E, r25	; 0x80071e <pxOverflowDelayedTaskList+0x1>
 9e8:	80 93 1d 07 	sts	0x071D, r24	; 0x80071d <pxOverflowDelayedTaskList>
 9ec:	80 91 02 07 	lds	r24, 0x0702	; 0x800702 <xNumOfOverflows>
 9f0:	8f 5f       	subi	r24, 0xFF	; 255
 9f2:	80 93 02 07 	sts	0x0702, r24	; 0x800702 <xNumOfOverflows>
 9f6:	11 de       	rcall	.-990    	; 0x61a <prvResetNextTaskUnblockTime>
 9f8:	80 91 ff 06 	lds	r24, 0x06FF	; 0x8006ff <xNextTaskUnblockTime>
 9fc:	90 91 00 07 	lds	r25, 0x0700	; 0x800700 <xNextTaskUnblockTime+0x1>
 a00:	e8 16       	cp	r14, r24
 a02:	f9 06       	cpc	r15, r25
 a04:	10 f4       	brcc	.+4      	; 0xa0a <xTaskIncrementTick+0x72>
 a06:	d1 2c       	mov	r13, r1
 a08:	50 c0       	rjmp	.+160    	; 0xaaa <xTaskIncrementTick+0x112>
 a0a:	d1 2c       	mov	r13, r1
 a0c:	cc 24       	eor	r12, r12
 a0e:	c3 94       	inc	r12
 a10:	e0 91 1f 07 	lds	r30, 0x071F	; 0x80071f <pxDelayedTaskList>
 a14:	f0 91 20 07 	lds	r31, 0x0720	; 0x800720 <pxDelayedTaskList+0x1>
 a18:	80 81       	ld	r24, Z
 a1a:	81 11       	cpse	r24, r1
 a1c:	07 c0       	rjmp	.+14     	; 0xa2c <xTaskIncrementTick+0x94>
 a1e:	8f ef       	ldi	r24, 0xFF	; 255
 a20:	9f ef       	ldi	r25, 0xFF	; 255
 a22:	90 93 00 07 	sts	0x0700, r25	; 0x800700 <xNextTaskUnblockTime+0x1>
 a26:	80 93 ff 06 	sts	0x06FF, r24	; 0x8006ff <xNextTaskUnblockTime>
 a2a:	3f c0       	rjmp	.+126    	; 0xaaa <xTaskIncrementTick+0x112>
 a2c:	e0 91 1f 07 	lds	r30, 0x071F	; 0x80071f <pxDelayedTaskList>
 a30:	f0 91 20 07 	lds	r31, 0x0720	; 0x800720 <pxDelayedTaskList+0x1>
 a34:	05 80       	ldd	r0, Z+5	; 0x05
 a36:	f6 81       	ldd	r31, Z+6	; 0x06
 a38:	e0 2d       	mov	r30, r0
 a3a:	c6 81       	ldd	r28, Z+6	; 0x06
 a3c:	d7 81       	ldd	r29, Z+7	; 0x07
 a3e:	8a 81       	ldd	r24, Y+2	; 0x02
 a40:	9b 81       	ldd	r25, Y+3	; 0x03
 a42:	e8 16       	cp	r14, r24
 a44:	f9 06       	cpc	r15, r25
 a46:	28 f4       	brcc	.+10     	; 0xa52 <xTaskIncrementTick+0xba>
 a48:	90 93 00 07 	sts	0x0700, r25	; 0x800700 <xNextTaskUnblockTime+0x1>
 a4c:	80 93 ff 06 	sts	0x06FF, r24	; 0x8006ff <xNextTaskUnblockTime>
 a50:	2c c0       	rjmp	.+88     	; 0xaaa <xTaskIncrementTick+0x112>
 a52:	8e 01       	movw	r16, r28
 a54:	0e 5f       	subi	r16, 0xFE	; 254
 a56:	1f 4f       	sbci	r17, 0xFF	; 255
 a58:	c8 01       	movw	r24, r16
 a5a:	5e dc       	rcall	.-1860   	; 0x318 <uxListRemove>
 a5c:	8c 89       	ldd	r24, Y+20	; 0x14
 a5e:	9d 89       	ldd	r25, Y+21	; 0x15
 a60:	89 2b       	or	r24, r25
 a62:	19 f0       	breq	.+6      	; 0xa6a <xTaskIncrementTick+0xd2>
 a64:	ce 01       	movw	r24, r28
 a66:	0c 96       	adiw	r24, 0x0c	; 12
 a68:	57 dc       	rcall	.-1874   	; 0x318 <uxListRemove>
 a6a:	8e 89       	ldd	r24, Y+22	; 0x16
 a6c:	90 91 06 07 	lds	r25, 0x0706	; 0x800706 <uxTopReadyPriority>
 a70:	98 17       	cp	r25, r24
 a72:	10 f4       	brcc	.+4      	; 0xa78 <xTaskIncrementTick+0xe0>
 a74:	80 93 06 07 	sts	0x0706, r24	; 0x800706 <uxTopReadyPriority>
 a78:	90 e0       	ldi	r25, 0x00	; 0
 a7a:	9c 01       	movw	r18, r24
 a7c:	22 0f       	add	r18, r18
 a7e:	33 1f       	adc	r19, r19
 a80:	22 0f       	add	r18, r18
 a82:	33 1f       	adc	r19, r19
 a84:	22 0f       	add	r18, r18
 a86:	33 1f       	adc	r19, r19
 a88:	82 0f       	add	r24, r18
 a8a:	93 1f       	adc	r25, r19
 a8c:	b8 01       	movw	r22, r16
 a8e:	8d 5c       	subi	r24, 0xCD	; 205
 a90:	98 4f       	sbci	r25, 0xF8	; 248
 a92:	f0 db       	rcall	.-2080   	; 0x274 <vListInsertEnd>
 a94:	e0 91 57 07 	lds	r30, 0x0757	; 0x800757 <pxCurrentTCB>
 a98:	f0 91 58 07 	lds	r31, 0x0758	; 0x800758 <pxCurrentTCB+0x1>
 a9c:	9e 89       	ldd	r25, Y+22	; 0x16
 a9e:	86 89       	ldd	r24, Z+22	; 0x16
 aa0:	98 17       	cp	r25, r24
 aa2:	08 f4       	brcc	.+2      	; 0xaa6 <xTaskIncrementTick+0x10e>
 aa4:	b5 cf       	rjmp	.-150    	; 0xa10 <xTaskIncrementTick+0x78>
 aa6:	dc 2c       	mov	r13, r12
 aa8:	b3 cf       	rjmp	.-154    	; 0xa10 <xTaskIncrementTick+0x78>
 aaa:	e0 91 57 07 	lds	r30, 0x0757	; 0x800757 <pxCurrentTCB>
 aae:	f0 91 58 07 	lds	r31, 0x0758	; 0x800758 <pxCurrentTCB+0x1>
 ab2:	86 89       	ldd	r24, Z+22	; 0x16
 ab4:	90 e0       	ldi	r25, 0x00	; 0
 ab6:	fc 01       	movw	r30, r24
 ab8:	ee 0f       	add	r30, r30
 aba:	ff 1f       	adc	r31, r31
 abc:	ee 0f       	add	r30, r30
 abe:	ff 1f       	adc	r31, r31
 ac0:	ee 0f       	add	r30, r30
 ac2:	ff 1f       	adc	r31, r31
 ac4:	8e 0f       	add	r24, r30
 ac6:	9f 1f       	adc	r25, r31
 ac8:	fc 01       	movw	r30, r24
 aca:	ed 5c       	subi	r30, 0xCD	; 205
 acc:	f8 4f       	sbci	r31, 0xF8	; 248
 ace:	80 81       	ld	r24, Z
 ad0:	82 30       	cpi	r24, 0x02	; 2
 ad2:	48 f0       	brcs	.+18     	; 0xae6 <xTaskIncrementTick+0x14e>
 ad4:	dd 24       	eor	r13, r13
 ad6:	d3 94       	inc	r13
 ad8:	06 c0       	rjmp	.+12     	; 0xae6 <xTaskIncrementTick+0x14e>
 ada:	80 91 04 07 	lds	r24, 0x0704	; 0x800704 <uxPendedTicks>
 ade:	8f 5f       	subi	r24, 0xFF	; 255
 ae0:	80 93 04 07 	sts	0x0704, r24	; 0x800704 <uxPendedTicks>
 ae4:	d1 2c       	mov	r13, r1
 ae6:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <xYieldPending>
 aea:	88 23       	and	r24, r24
 aec:	11 f0       	breq	.+4      	; 0xaf2 <xTaskIncrementTick+0x15a>
 aee:	dd 24       	eor	r13, r13
 af0:	d3 94       	inc	r13
 af2:	8d 2d       	mov	r24, r13
 af4:	df 91       	pop	r29
 af6:	cf 91       	pop	r28
 af8:	1f 91       	pop	r17
 afa:	0f 91       	pop	r16
 afc:	ff 90       	pop	r15
 afe:	ef 90       	pop	r14
 b00:	df 90       	pop	r13
 b02:	cf 90       	pop	r12
 b04:	08 95       	ret

00000b06 <xTaskResumeAll>:
 b06:	df 92       	push	r13
 b08:	ef 92       	push	r14
 b0a:	ff 92       	push	r15
 b0c:	0f 93       	push	r16
 b0e:	1f 93       	push	r17
 b10:	cf 93       	push	r28
 b12:	df 93       	push	r29
 b14:	0f b6       	in	r0, 0x3f	; 63
 b16:	f8 94       	cli
 b18:	0f 92       	push	r0
 b1a:	80 91 fc 06 	lds	r24, 0x06FC	; 0x8006fc <uxSchedulerSuspended>
 b1e:	81 50       	subi	r24, 0x01	; 1
 b20:	80 93 fc 06 	sts	0x06FC, r24	; 0x8006fc <uxSchedulerSuspended>
 b24:	80 91 fc 06 	lds	r24, 0x06FC	; 0x8006fc <uxSchedulerSuspended>
 b28:	81 11       	cpse	r24, r1
 b2a:	59 c0       	rjmp	.+178    	; 0xbde <xTaskResumeAll+0xd8>
 b2c:	80 91 09 07 	lds	r24, 0x0709	; 0x800709 <uxCurrentNumberOfTasks>
 b30:	81 11       	cpse	r24, r1
 b32:	30 c0       	rjmp	.+96     	; 0xb94 <xTaskResumeAll+0x8e>
 b34:	57 c0       	rjmp	.+174    	; 0xbe4 <xTaskResumeAll+0xde>
 b36:	d7 01       	movw	r26, r14
 b38:	15 96       	adiw	r26, 0x05	; 5
 b3a:	ed 91       	ld	r30, X+
 b3c:	fc 91       	ld	r31, X
 b3e:	16 97       	sbiw	r26, 0x06	; 6
 b40:	c6 81       	ldd	r28, Z+6	; 0x06
 b42:	d7 81       	ldd	r29, Z+7	; 0x07
 b44:	ce 01       	movw	r24, r28
 b46:	0c 96       	adiw	r24, 0x0c	; 12
 b48:	e7 db       	rcall	.-2098   	; 0x318 <uxListRemove>
 b4a:	8e 01       	movw	r16, r28
 b4c:	0e 5f       	subi	r16, 0xFE	; 254
 b4e:	1f 4f       	sbci	r17, 0xFF	; 255
 b50:	c8 01       	movw	r24, r16
 b52:	e2 db       	rcall	.-2108   	; 0x318 <uxListRemove>
 b54:	8e 89       	ldd	r24, Y+22	; 0x16
 b56:	90 91 06 07 	lds	r25, 0x0706	; 0x800706 <uxTopReadyPriority>
 b5a:	98 17       	cp	r25, r24
 b5c:	10 f4       	brcc	.+4      	; 0xb62 <xTaskResumeAll+0x5c>
 b5e:	80 93 06 07 	sts	0x0706, r24	; 0x800706 <uxTopReadyPriority>
 b62:	90 e0       	ldi	r25, 0x00	; 0
 b64:	9c 01       	movw	r18, r24
 b66:	22 0f       	add	r18, r18
 b68:	33 1f       	adc	r19, r19
 b6a:	22 0f       	add	r18, r18
 b6c:	33 1f       	adc	r19, r19
 b6e:	22 0f       	add	r18, r18
 b70:	33 1f       	adc	r19, r19
 b72:	82 0f       	add	r24, r18
 b74:	93 1f       	adc	r25, r19
 b76:	b8 01       	movw	r22, r16
 b78:	8d 5c       	subi	r24, 0xCD	; 205
 b7a:	98 4f       	sbci	r25, 0xF8	; 248
 b7c:	7b db       	rcall	.-2314   	; 0x274 <vListInsertEnd>
 b7e:	e0 91 57 07 	lds	r30, 0x0757	; 0x800757 <pxCurrentTCB>
 b82:	f0 91 58 07 	lds	r31, 0x0758	; 0x800758 <pxCurrentTCB+0x1>
 b86:	9e 89       	ldd	r25, Y+22	; 0x16
 b88:	86 89       	ldd	r24, Z+22	; 0x16
 b8a:	98 17       	cp	r25, r24
 b8c:	68 f0       	brcs	.+26     	; 0xba8 <xTaskResumeAll+0xa2>
 b8e:	d0 92 03 07 	sts	0x0703, r13	; 0x800703 <xYieldPending>
 b92:	0a c0       	rjmp	.+20     	; 0xba8 <xTaskResumeAll+0xa2>
 b94:	c0 e0       	ldi	r28, 0x00	; 0
 b96:	d0 e0       	ldi	r29, 0x00	; 0
 b98:	0f 2e       	mov	r0, r31
 b9a:	f4 e1       	ldi	r31, 0x14	; 20
 b9c:	ef 2e       	mov	r14, r31
 b9e:	f7 e0       	ldi	r31, 0x07	; 7
 ba0:	ff 2e       	mov	r15, r31
 ba2:	f0 2d       	mov	r31, r0
 ba4:	dd 24       	eor	r13, r13
 ba6:	d3 94       	inc	r13
 ba8:	f7 01       	movw	r30, r14
 baa:	80 81       	ld	r24, Z
 bac:	81 11       	cpse	r24, r1
 bae:	c3 cf       	rjmp	.-122    	; 0xb36 <xTaskResumeAll+0x30>
 bb0:	cd 2b       	or	r28, r29
 bb2:	09 f0       	breq	.+2      	; 0xbb6 <xTaskResumeAll+0xb0>
 bb4:	32 dd       	rcall	.-1436   	; 0x61a <prvResetNextTaskUnblockTime>
 bb6:	c0 91 04 07 	lds	r28, 0x0704	; 0x800704 <uxPendedTicks>
 bba:	cc 23       	and	r28, r28
 bbc:	49 f0       	breq	.+18     	; 0xbd0 <xTaskResumeAll+0xca>
 bbe:	d1 e0       	ldi	r29, 0x01	; 1
 bc0:	eb de       	rcall	.-554    	; 0x998 <xTaskIncrementTick>
 bc2:	81 11       	cpse	r24, r1
 bc4:	d0 93 03 07 	sts	0x0703, r29	; 0x800703 <xYieldPending>
 bc8:	c1 50       	subi	r28, 0x01	; 1
 bca:	d1 f7       	brne	.-12     	; 0xbc0 <xTaskResumeAll+0xba>
 bcc:	10 92 04 07 	sts	0x0704, r1	; 0x800704 <uxPendedTicks>
 bd0:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <xYieldPending>
 bd4:	88 23       	and	r24, r24
 bd6:	29 f0       	breq	.+10     	; 0xbe2 <xTaskResumeAll+0xdc>
 bd8:	6c dc       	rcall	.-1832   	; 0x4b2 <vPortYield>
 bda:	81 e0       	ldi	r24, 0x01	; 1
 bdc:	03 c0       	rjmp	.+6      	; 0xbe4 <xTaskResumeAll+0xde>
 bde:	80 e0       	ldi	r24, 0x00	; 0
 be0:	01 c0       	rjmp	.+2      	; 0xbe4 <xTaskResumeAll+0xde>
 be2:	80 e0       	ldi	r24, 0x00	; 0
 be4:	0f 90       	pop	r0
 be6:	0f be       	out	0x3f, r0	; 63
 be8:	df 91       	pop	r29
 bea:	cf 91       	pop	r28
 bec:	1f 91       	pop	r17
 bee:	0f 91       	pop	r16
 bf0:	ff 90       	pop	r15
 bf2:	ef 90       	pop	r14
 bf4:	df 90       	pop	r13
 bf6:	08 95       	ret

00000bf8 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 bf8:	cf 93       	push	r28
 bfa:	df 93       	push	r29
 bfc:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 bfe:	89 2b       	or	r24, r25
 c00:	39 f0       	breq	.+14     	; 0xc10 <vTaskDelay+0x18>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
 c02:	c4 de       	rcall	.-632    	; 0x98c <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 c04:	60 e0       	ldi	r22, 0x00	; 0
 c06:	ce 01       	movw	r24, r28
			}
			xAlreadyYielded = xTaskResumeAll();
 c08:	5b dd       	rcall	.-1354   	; 0x6c0 <prvAddCurrentTaskToDelayedList>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 c0a:	7d df       	rcall	.-262    	; 0xb06 <xTaskResumeAll>
 c0c:	81 11       	cpse	r24, r1
		{
			portYIELD_WITHIN_API();
 c0e:	01 c0       	rjmp	.+2      	; 0xc12 <vTaskDelay+0x1a>
 c10:	50 dc       	rcall	.-1888   	; 0x4b2 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 c12:	df 91       	pop	r29
 c14:	cf 91       	pop	r28
 c16:	08 95       	ret

00000c18 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 c18:	80 91 fc 06 	lds	r24, 0x06FC	; 0x8006fc <uxSchedulerSuspended>
 c1c:	88 23       	and	r24, r24
 c1e:	21 f0       	breq	.+8      	; 0xc28 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 c20:	81 e0       	ldi	r24, 0x01	; 1
 c22:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <xYieldPending>
 c26:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
 c28:	10 92 03 07 	sts	0x0703, r1	; 0x800703 <xYieldPending>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 c2c:	20 91 06 07 	lds	r18, 0x0706	; 0x800706 <uxTopReadyPriority>
 c30:	82 2f       	mov	r24, r18
 c32:	90 e0       	ldi	r25, 0x00	; 0
 c34:	fc 01       	movw	r30, r24
 c36:	ee 0f       	add	r30, r30
 c38:	ff 1f       	adc	r31, r31
 c3a:	ee 0f       	add	r30, r30
 c3c:	ff 1f       	adc	r31, r31
 c3e:	ee 0f       	add	r30, r30
 c40:	ff 1f       	adc	r31, r31
 c42:	e8 0f       	add	r30, r24
 c44:	f9 1f       	adc	r31, r25
 c46:	ed 5c       	subi	r30, 0xCD	; 205
 c48:	f8 4f       	sbci	r31, 0xF8	; 248
 c4a:	30 81       	ld	r19, Z
 c4c:	31 11       	cpse	r19, r1
 c4e:	11 c0       	rjmp	.+34     	; 0xc72 <vTaskSwitchContext+0x5a>
 c50:	21 50       	subi	r18, 0x01	; 1
 c52:	82 2f       	mov	r24, r18
 c54:	90 e0       	ldi	r25, 0x00	; 0
 c56:	fc 01       	movw	r30, r24
 c58:	ee 0f       	add	r30, r30
 c5a:	ff 1f       	adc	r31, r31
 c5c:	ee 0f       	add	r30, r30
 c5e:	ff 1f       	adc	r31, r31
 c60:	ee 0f       	add	r30, r30
 c62:	ff 1f       	adc	r31, r31
 c64:	e8 0f       	add	r30, r24
 c66:	f9 1f       	adc	r31, r25
 c68:	ed 5c       	subi	r30, 0xCD	; 205
 c6a:	f8 4f       	sbci	r31, 0xF8	; 248
 c6c:	30 81       	ld	r19, Z
 c6e:	33 23       	and	r19, r19
 c70:	79 f3       	breq	.-34     	; 0xc50 <vTaskSwitchContext+0x38>
 c72:	ac 01       	movw	r20, r24
 c74:	44 0f       	add	r20, r20
 c76:	55 1f       	adc	r21, r21
 c78:	44 0f       	add	r20, r20
 c7a:	55 1f       	adc	r21, r21
 c7c:	44 0f       	add	r20, r20
 c7e:	55 1f       	adc	r21, r21
 c80:	48 0f       	add	r20, r24
 c82:	59 1f       	adc	r21, r25
 c84:	da 01       	movw	r26, r20
 c86:	ad 5c       	subi	r26, 0xCD	; 205
 c88:	b8 4f       	sbci	r27, 0xF8	; 248
 c8a:	11 96       	adiw	r26, 0x01	; 1
 c8c:	ed 91       	ld	r30, X+
 c8e:	fc 91       	ld	r31, X
 c90:	12 97       	sbiw	r26, 0x02	; 2
 c92:	02 80       	ldd	r0, Z+2	; 0x02
 c94:	f3 81       	ldd	r31, Z+3	; 0x03
 c96:	e0 2d       	mov	r30, r0
 c98:	12 96       	adiw	r26, 0x02	; 2
 c9a:	fc 93       	st	X, r31
 c9c:	ee 93       	st	-X, r30
 c9e:	11 97       	sbiw	r26, 0x01	; 1
 ca0:	4a 5c       	subi	r20, 0xCA	; 202
 ca2:	58 4f       	sbci	r21, 0xF8	; 248
 ca4:	e4 17       	cp	r30, r20
 ca6:	f5 07       	cpc	r31, r21
 ca8:	29 f4       	brne	.+10     	; 0xcb4 <vTaskSwitchContext+0x9c>
 caa:	42 81       	ldd	r20, Z+2	; 0x02
 cac:	53 81       	ldd	r21, Z+3	; 0x03
 cae:	fd 01       	movw	r30, r26
 cb0:	52 83       	std	Z+2, r21	; 0x02
 cb2:	41 83       	std	Z+1, r20	; 0x01
 cb4:	fc 01       	movw	r30, r24
 cb6:	ee 0f       	add	r30, r30
 cb8:	ff 1f       	adc	r31, r31
 cba:	ee 0f       	add	r30, r30
 cbc:	ff 1f       	adc	r31, r31
 cbe:	ee 0f       	add	r30, r30
 cc0:	ff 1f       	adc	r31, r31
 cc2:	8e 0f       	add	r24, r30
 cc4:	9f 1f       	adc	r25, r31
 cc6:	fc 01       	movw	r30, r24
 cc8:	ed 5c       	subi	r30, 0xCD	; 205
 cca:	f8 4f       	sbci	r31, 0xF8	; 248
 ccc:	01 80       	ldd	r0, Z+1	; 0x01
 cce:	f2 81       	ldd	r31, Z+2	; 0x02
 cd0:	e0 2d       	mov	r30, r0
 cd2:	86 81       	ldd	r24, Z+6	; 0x06
 cd4:	97 81       	ldd	r25, Z+7	; 0x07
 cd6:	90 93 58 07 	sts	0x0758, r25	; 0x800758 <pxCurrentTCB+0x1>
 cda:	80 93 57 07 	sts	0x0757, r24	; 0x800757 <pxCurrentTCB>
 cde:	20 93 06 07 	sts	0x0706, r18	; 0x800706 <uxTopReadyPriority>
 ce2:	08 95       	ret

00000ce4 <_exit>:
 ce4:	f8 94       	cli

00000ce6 <__stop_program>:
 ce6:	ff cf       	rjmp	.-2      	; 0xce6 <__stop_program>
